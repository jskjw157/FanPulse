# FanPulse 인증 시스템 가이드

> 프론트엔드 개발자를 위한 OAuth + JWT 인증 시스템 문서

## 목차

1. [개요](#개요)
2. [인증 플로우](#인증-플로우)
3. [토큰 관리](#토큰-관리)
4. [프론트엔드 구현 가이드](#프론트엔드-구현-가이드)
5. [API 레퍼런스](#api-레퍼런스)
6. [트러블슈팅](#트러블슈팅)

---

## 개요

### 인증 방식

FanPulse는 **Google OAuth 2.0 + JWT** 방식을 사용합니다.

| 구성 요소 | 역할 |
|----------|------|
| Google OAuth | 사용자 신원 확인 (소셜 로그인) |
| JWT (Access Token) | API 요청 인증 |
| JWT (Refresh Token) | Access Token 재발급 |

### 토큰 저장 방식

| 플랫폼 | 저장 방식 | 보안 |
|--------|----------|------|
| **웹 브라우저** | httpOnly 쿠키 | XSS 공격 방지 |
| **모바일 앱** | Secure Storage + Authorization 헤더 | 앱 내 보안 저장소 |

```mermaid
flowchart LR
    subgraph Web ["웹 브라우저"]
        W1[API 요청] --> W2[쿠키 자동 전송]
    end

    subgraph Mobile ["모바일 앱"]
        M1[API 요청] --> M2[Authorization 헤더 추가]
    end

    subgraph Backend ["FanPulse 백엔드"]
        B1{토큰 추출}
        B1 --> |1순위| B2[Authorization 헤더]
        B1 --> |2순위| B3[Cookie]
        B2 --> B4[JWT 검증]
        B3 --> B4
    end

    W2 --> B1
    M2 --> B1
```

---

## 인증 플로우

### 1. Google OAuth 로그인 플로우

```mermaid
sequenceDiagram
    autonumber
    participant User as 사용자
    participant Web as FanPulse 웹
    participant API as FanPulse 백엔드
    participant Google as Google

    User->>Web: 구글 로그인 버튼 클릭
    Web->>Google: Google OAuth 팝업 열기
    User->>Google: 구글 계정 로그인
    Google-->>Web: Google ID Token (JWT)

    Web->>API: POST /auth/google { idToken }
    API->>Google: ID Token 검증 요청
    Google-->>API: 사용자 정보 (이메일, 이름)

    Note over API: DB에서 사용자 조회/생성
    Note over API: FanPulse JWT 생성<br/>(Access + Refresh Token)

    API-->>Web: Set-Cookie: fanpulse_access_token<br/>Set-Cookie: fanpulse_refresh_token
    Web-->>User: 로그인 완료
```

### 2. 두 종류의 JWT

| 토큰 | 발급자 | 용도 | 비유 |
|-----|-------|------|------|
| **Google ID Token** | Google | 구글 계정 확인 (1회용) | 신분증 |
| **FanPulse JWT** | FanPulse | API 요청 인증 (계속 사용) | 회원카드 |

**핵심 포인트:**
- Google ID Token은 로그인 순간만 사용
- 이후 모든 API 요청은 FanPulse JWT 사용

---

## 토큰 관리

### 토큰 유효기간

| 토큰 | 유효기간 | 쿠키 이름 |
|-----|---------|----------|
| **Access Token** | 1시간 | `fanpulse_access_token` |
| **Refresh Token** | 7일 | `fanpulse_refresh_token` |

### 토큰 갱신 플로우

```mermaid
sequenceDiagram
    autonumber
    participant User as 사용자
    participant Web as FanPulse 웹
    participant API as FanPulse 백엔드

    User->>Web: API 요청 (게시글 작성 등)
    Web->>API: Access Token (만료됨) - Cookie 자동 전송
    API-->>Web: 401 Unauthorized

    Note over Web: 토큰 갱신 시도

    Web->>API: POST /auth/refresh (Refresh Token 쿠키)

    alt Refresh Token 유효
        API-->>Web: Set-Cookie: 새 Access Token
        Web->>API: 원래 API 요청 재시도
        API-->>Web: 200 OK
        Web-->>User: 요청 성공
    else Refresh Token 만료
        API-->>Web: 401 Unauthorized
        Web-->>User: 로그인 페이지로 이동
    end
```

### 시나리오별 동작

| 시나리오 | Access Token | Refresh Token | 결과 |
|---------|-------------|---------------|------|
| 정상 | 유효 | 유효 | API 요청 성공 |
| 갱신 필요 | 만료 | 유효 | 자동 갱신 후 재시도 |
| 재로그인 필요 | 만료 | 만료 | 로그인 페이지로 이동 |

```mermaid
stateDiagram-v2
    [*] --> 비로그인: 앱 시작

    비로그인 --> 로그인중: Google 로그인 시도
    로그인중 --> 인증됨: 로그인 성공
    로그인중 --> 비로그인: 로그인 실패

    인증됨 --> 토큰갱신중: Access Token 만료
    토큰갱신중 --> 인증됨: Refresh 성공
    토큰갱신중 --> 비로그인: Refresh Token 만료

    인증됨 --> 비로그인: 로그아웃
```

---

## 프론트엔드 구현 가이드

### 1. API 클라이언트 설정

`web/src/lib/api-client.ts`:

```typescript
import axios, { AxiosInstance } from "axios";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8080/api/v1";

export const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true,  // 쿠키 자동 전송 (필수!)
});

// 401 에러 시 자동 갱신
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // 401이고 재시도 안 한 경우
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // 토큰 갱신 시도
        await apiClient.post("/auth/refresh");
        // 원래 요청 재시도
        return apiClient.request(originalRequest);
      } catch (refreshError) {
        // 갱신 실패 → 로그인 페이지로
        window.location.href = "/login";
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

**중요:** `withCredentials: true` 필수! 이게 있어야 쿠키가 자동 전송됩니다.

### 2. AuthContext 사용

`web/src/contexts/AuthContext.tsx`:

```typescript
"use client";

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { checkAuthStatus, logout as apiLogout } from "@/lib/auth";

interface AuthUser {
  id: number;
  email: string;
  nickname: string;
}

interface AuthContextValue {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: AuthUser | null;
  logout: () => Promise<void>;
  refreshAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [user, setUser] = useState<AuthUser | null>(null);

  // 인증 상태 확인 (서버에 /auth/me 호출)
  const refreshAuth = async () => {
    try {
      const response = await checkAuthStatus();
      setIsAuthenticated(response.authenticated);
      setUser(response.user || null);
    } catch {
      setIsAuthenticated(false);
      setUser(null);
    }
  };

  // 로그아웃
  const logout = async () => {
    try {
      await apiLogout();
    } finally {
      setIsAuthenticated(false);
      setUser(null);
      window.location.href = "/login";
    }
  };

  // 앱 시작 시 인증 상태 확인
  useEffect(() => {
    refreshAuth().finally(() => setIsLoading(false));
  }, []);

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLoading, user, logout, refreshAuth }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
}
```

### 3. ProtectedRoute 컴포넌트

보호된 페이지를 감싸는 컴포넌트:

```typescript
"use client";

import { useAuth } from "@/contexts/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push("/login");
    }
  }, [isAuthenticated, isLoading, router]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-600" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return null;
  }

  return <>{children}</>;
}
```

### 4. 보호된 페이지 예시

```typescript
"use client";

import ProtectedRoute from "@/components/auth/ProtectedRoute";
import { useAuth } from "@/contexts/AuthContext";

export default function MyPage() {
  const { user, logout } = useAuth();

  return (
    <ProtectedRoute>
      <div>
        <h1>마이페이지</h1>
        <p>안녕하세요, {user?.nickname}님!</p>
        <button onClick={logout}>로그아웃</button>
      </div>
    </ProtectedRoute>
  );
}
```

### 5. 로그인 페이지 예시

```typescript
"use client";

import { useAuth } from "@/contexts/AuthContext";
import { loginWithGoogle } from "@/lib/auth";
import { useGoogleLogin } from "@react-oauth/google";

export default function LoginPage() {
  const { refreshAuth } = useAuth();

  const googleLogin = useGoogleLogin({
    onSuccess: async (response) => {
      try {
        // 백엔드에 Google 토큰 전송
        await loginWithGoogle({ idToken: response.credential });
        // 인증 상태 갱신
        await refreshAuth();
        // 홈으로 이동
        window.location.href = "/";
      } catch (error) {
        console.error("로그인 실패:", error);
      }
    },
    flow: "implicit",
  });

  return (
    <div>
      <button onClick={() => googleLogin()}>
        Google로 로그인
      </button>
    </div>
  );
}
```

---

## API 레퍼런스

### 인증 관련 API

| Method | Endpoint | 설명 | 인증 필요 |
|--------|----------|------|----------|
| POST | `/api/v1/auth/google` | Google OAuth 로그인 | X |
| POST | `/api/v1/auth/refresh` | 토큰 갱신 | X (Refresh Token 쿠키) |
| POST | `/api/v1/auth/logout` | 로그아웃 | X |
| GET | `/api/v1/auth/me` | 현재 사용자 정보 | O |

### 요청/응답 예시

#### POST /api/v1/auth/google

**Request:**
```json
{
  "idToken": "eyJhbGciOiJSUzI1NiIsInR5cCI6..."
}
```

**Response:**
```json
{
  "user": {
    "id": 123,
    "email": "user@gmail.com",
    "nickname": "사용자"
  }
}
```

**Response Headers:**
```
Set-Cookie: fanpulse_access_token=...; HttpOnly; Path=/; Max-Age=3600
Set-Cookie: fanpulse_refresh_token=...; HttpOnly; Path=/; Max-Age=604800
```

#### GET /api/v1/auth/me

**Response (인증됨):**
```json
{
  "authenticated": true,
  "user": {
    "id": 123,
    "email": "user@gmail.com",
    "nickname": "사용자"
  }
}
```

**Response (비인증):**
```json
{
  "authenticated": false,
  "user": null
}
```

#### POST /api/v1/auth/logout

**Response Headers:**
```
Set-Cookie: fanpulse_access_token=; HttpOnly; Path=/; Max-Age=0
Set-Cookie: fanpulse_refresh_token=; HttpOnly; Path=/; Max-Age=0
```

---

## 트러블슈팅

### 1. CORS 에러

**증상:**
```
Access to XMLHttpRequest at 'http://localhost:8080/api/v1/...'
from origin 'http://localhost:3000' has been blocked by CORS policy
```

**해결:**
- 백엔드 `SecurityConfig.kt`에 CORS 설정 확인
- `allowedOrigins`에 프론트엔드 URL 포함 확인
- `allowCredentials = true` 설정 확인

### 2. 쿠키가 전송되지 않음

**증상:**
- 로그인은 성공하는데 이후 API 요청에서 401 에러

**해결:**
```typescript
// api-client.ts
axios.create({
  withCredentials: true,  // 이 설정 확인!
});
```

### 3. 로그인 후 상태가 업데이트 안 됨

**증상:**
- 로그인 성공 후에도 UI가 비로그인 상태로 표시

**해결:**
```typescript
// 로그인 성공 후 반드시 refreshAuth() 호출
await loginWithGoogle({ idToken });
await refreshAuth();  // 이거 호출 확인!
```

### 4. 401 에러가 계속 발생

**증상:**
- 토큰 갱신 후에도 계속 401 에러

**가능한 원인:**
1. Refresh Token도 만료됨 → 재로그인 필요
2. 서버 시간과 클라이언트 시간 차이
3. 토큰 서명 키 변경됨

---

## 모바일 앱 개발자 참고

모바일 앱은 쿠키 대신 **Authorization 헤더**를 사용합니다.

### 토큰 저장

```kotlin
// Android - EncryptedSharedPreferences
val accessToken = secureStorage.getString("access_token")
val refreshToken = secureStorage.getString("refresh_token")
```

```swift
// iOS - Keychain
let accessToken = keychain.get("access_token")
let refreshToken = keychain.get("refresh_token")
```

### API 요청

```
GET /api/v1/posts
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

### 로그인 응답

모바일 앱은 쿠키 대신 응답 바디에서 토큰을 받습니다:

```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6...",
  "user": { ... }
}
```

---

## 보안 체크리스트

- [x] httpOnly 쿠키 사용 (XSS 방지)
- [x] SameSite=Lax 설정 (CSRF 방지)
- [x] Access Token 짧은 유효기간 (1시간)
- [x] Refresh Token으로 Access Token만 교체
- [x] 로그아웃 시 쿠키 완전 삭제
- [x] HTTPS 환경에서 Secure 쿠키 사용

---

*마지막 업데이트: 2025-01-26*
